[ { "title": "[Git] Git Command", "url": "/posts/git_command/", "categories": "Git", "tags": "Git", "date": "2023-06-22 00:00:00 +0900", "snippet": "Git Command설정 초기화git config --global user.name \"Your name\"git config --global user.email \"eamil@email.com\"커밋하지 않고 변경사항 저장git stashgit stash popGit 저장소에 포함되지 않은 파일 삭제git clean수정한 파일 되돌리기git checkout...", "content": "Git Command설정 초기화git config --global user.name \"Your name\"git config --global user.email \"eamil@email.com\"커밋하지 않고 변경사항 저장git stashgit stash popGit 저장소에 포함되지 않은 파일 삭제git clean수정한 파일 되돌리기git checkout -- filename모두 되돌리기git restore ." }, { "title": "[Unreal Engine] Circular Ring Material", "url": "/posts/CircularRing/", "categories": "Unreal Engine", "tags": "Unreal Engine, Material", "date": "2023-06-21 00:00:00 +0900", "snippet": "원형의 Progress Bar 혹은 차트에 활용", "content": "원형의 Progress Bar 혹은 차트에 활용" }, { "title": "[C++] 스트링 리터럴(String Literal)", "url": "/posts/String_Literal/", "categories": "C++", "tags": "C++", "date": "2023-06-04 00:00:00 +0900", "snippet": "스트링 리터럴(String Literal)cout &lt;&lt; \"hello\" &lt;&lt; endl;여기 나온 ‘hello’처럼 변수에 담지 않고 곧바로 값으로 표현한 스트링을 스트링 리터럴(String Literal)이라고 한다.스트링 리터럴은 내부적으로 메모리의 읽기 전용 영역에 저장된다. 그래서 컴파일러는 같은 스트링 리터럴이 코드에 여러번...", "content": "스트링 리터럴(String Literal)cout &lt;&lt; \"hello\" &lt;&lt; endl;여기 나온 ‘hello’처럼 변수에 담지 않고 곧바로 값으로 표현한 스트링을 스트링 리터럴(String Literal)이라고 한다.스트링 리터럴은 내부적으로 메모리의 읽기 전용 영역에 저장된다. 그래서 컴파일러는 같은 스트링 리터럴이 코드에 여러번 나오면 그중 한 스트링에 대한 레퍼런스를 재사용하는 방식으로 메모리를 절약한다. 이를 리터럴 풀링(Literal Pooling)이라 한다.스트링 리터럴을 변수에 대입할 수는 있지만, 메모리의 읽기 전용 영역에 있게 되거나 동일한 리터럴을 여러 곳에서 공유할 수 있기 때문에 변수에 저장하면 위험하다. C++ 표준에서는 스트링 리터럴을 ‘const char가 n개인 배열’ 타입으로 정의하고 있다. const 없이 char* 타입 변수에 스트링 리터럴을 대입하더라도 그 값을 변경하지 않는 한 프로그램 실행에는 아무런 문제없다. 그러나 스트링 리터럴을 수정하는 동작에 대해서는 명확히 정의돼 있지 않다.char* ptr = \"hello\"; \t// 변수에 스트링 리터럴을 대입한다.ptr[1] = 'a';\t\t\t// 결과를 예측할 수 없다.스트링 리터럴을 참조할 때는 const 문자에 대한 포인터를 사용하는 것이 훨씬 안전하다.const char* ptr = \"hello\";\t// 변수에 스트링 리터럴을 대입한다.ptr[1] = 'a';\t\t\t\t// 읽기 전용 메모리에 값을 쓰기 때문에 에러가 발생한다.문자 배열(char[])의 초깃값을 설정할 때도 스트링 리터럴을 사용한다. 이때 컴파일러는 주어진 스트링을 충분히 담을 정도로 큰 배열을 생성한 뒤 여기에 실제 스트링값을 복사한다. 컴파일러는 이렇게 만든 스트링 리터럴을 읽기 전용 메모리에 넣지 않으며 재사용하지도 않는다.char arr[] = \"hello\";\t// 컴파일러는 적절한 크기의 문자 배열 arr을 생성한다.arr[1] = 'a';\t\t\t// 이제 스트링을 수정할 수 있다.로 스트링 리터럴(Raw String Literal)로 스트링 리터럴(Raw String Literal)이란 여러 줄에 걸쳐 작성한 스트링 리터럴로서, 그 안에 담긴 인용부호를 이스케이프 시퀀스로 표현할 필요가 없고, \\t나 \\n과 같은 이스케이프 시퀀스를 일반 텍스트로 취급한다.에러 예제const char* str = \"Hello \"World\"!\";\t// 에러가 발생한다!이스케이프 시퀀스const char* str = \"Hello \\\"World\\\"!\";로 스트링 리터럴 예제R”(로 시작해서 )”로 끝난다.const char* str = R\"(Hello \"World\"!)\";\t로 스트링 리터럴을 사용하지 않고 여러 줄에 걸친 스트링을 표현하려면 스트링 안에서 줄이 바뀌는 지점에 \\n을 넣어야 한다.const char* str = \"Line 1\\nLine 2\";로 스트링 리터럴을 표현할 때는 \\n 대신 엔터키를 누르면 된다.const char* str = R\"(Line 1Line2)\";확장 로 스트링 리터럴(Extended Raw String Literal)로 스트링 리터럴은 )”로 끝나기 때문에 그 안에 )”를 넣을 수 없다. 넣게 되면 에러가 발생한다.const char* str = R\"(Embedded )\" characters)\";\t// 에러가 발생한다.)”를 추가하려면 확장 로 스트링 리터럴(Extended Raw String Literal) 구문으로 표현해야 한다.R\"d-char-sequence(r-char-sequence)d-char-sequence\"여기서 r-char-sequence에 해당하는 부분이 실제 로 스트링이다. d-char-sequence라고 표현한 부분은 구분자 시퀀스(Delimeter Sequence)로서, 반드시 로 스트링 리터럴의 시작과 끝에 똑같이 나와야한다. 이 구분자는 최대 16개의 문자를 가질 수 있다. 이때 구분자 시퀀스는 로 스트링 리터럴 안에 나오지 않는 값으로 지정해야 한다.구분자 시퀀스 수정한 예제const char* str = R\"-(Embedded )\" characters)-\";로 스트링 리터럴을 사용하면 데이터베이스 쿼리 스트링이나 정규표현식, 파일 경로 등을 쉽게 표현할 수 있다.참고 마크 그레고리, 『전문가를 위한 C++(4판)』, 남기혁" }, { "title": "[C++] 네임스페이스(Namespace)", "url": "/posts/Namespace/", "categories": "C++", "tags": "C++", "date": "2023-05-16 00:00:00 +0900", "snippet": "네임스페이스(Namespace)네임스페이스는 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념이다.예를 들어 foo() 함수를 정의해서 코드를 작성하다가 외부 라이브러리를 추가했더니 거기에도 foo() 함수가 있는 경우가 있다. 이때 컴파일러는 foo()란 이름만 보고서는 어느 함수를 가리키는지 알 수 없다.이럴 때 네임스페이스를 사용하면...", "content": "네임스페이스(Namespace)네임스페이스는 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념이다.예를 들어 foo() 함수를 정의해서 코드를 작성하다가 외부 라이브러리를 추가했더니 거기에도 foo() 함수가 있는 경우가 있다. 이때 컴파일러는 foo()란 이름만 보고서는 어느 함수를 가리키는지 알 수 없다.이럴 때 네임스페이스를 사용하면 어떤 이름이 어디에 속해 있는지 문맥을 정의할 수 있다.namespace.hnamespace mycode{ void foo();}네임스페이스는 이렇게 함수나 메서드의 선언뿐만 아니라 구현 부분도 묶을 수 있다. 예를 들어 foo() 함수의 구현 부분을 namespace.cpp에 작성할 때 네임스페이스를 지정하는 방법은 다음과 같다.namespace.cpp#include &lt;iostream&gt;#include \"namespaces.h\"void mycode::foo(){ std::cout &lt;&lt; \"foo() called in the mycode namespace\" &lt;&lt; std::endl;}또는#include &lt;iostream&gt;#include \"namespaces.h\"namespace mycode{ void foo() { std::cout &lt;&lt; \"foo() called in the mycode namespace\" &lt;&lt; std::endl;\t}}이처럼 foo()를 mycode 네임스페이스 아래에 두면 외부 라이브러리에 foo()가 있더라도 서로 구분할 수 있다. 네임스페이스를 적용한 foo()를 호출하려면 ::(스코프 지정 연산자 scope resolution operator)를 이용하여 함수 이름 앞에 네임스페이스를 붙인다.mycode::foo(); // mycode 네임스페이스에 정의된 foo() 함수를 호출한다.mycode 네임스페이스 블록 안에서 접근할 때는 네임스페이스를 접두어로 붙이지 않아도 된다. 이렇게 네임스페이스를 생략하면 코드의 가독성을 좀 더 높일 수 있다. 또한 using 지시자를 이용하면 네임스페이스 접두어를 생략할 수도 있다. 컴파일러는 using 지시자를 보면 그 뒤에 나오는 문장부터는 using에 지정된 네임스페이스에 속하는 것으로 처리한다.#include \"namespaces.h\"using namespace mycode;int main(){ foo();\t// mycode::foo();와 같다. return 0;}이어지는 코드에서는 cout 앞에 네임스페이스 접두어를 생략해도 된다. 하지면 std 네임스페이스의 다른 항목을 사용하려면 네임스페이스 접두어를 붙여야 한다.using std::cout;cout &lt;&lt; \"Hello, World!\" &lt;&lt; std::endl; 헤더파일 안에서는 절대로 using 문을 작성하면 안 된다. 그러면 그 헤더 파일을 인클루드하는 모든 파일에서 using 문으로 지정한 방식으로 호출해야 한다.C++17 중첩된 네임스페이스C++17에서는 중첩된 네임스페이스를 좀 더 쉽게 사용할 수 있도록 개선했다. 중첩된 네임스페이스란 네임스페이스 안에 있는 네임스페이스를 말한다. C++17 이전에는 다음과 같이 작성했다.namespace MyLibraries{ namespace Networking { namespace FTP { /* ... */ } }}C++17부터는 다음과 같이 간결해졌다.namespace MyLibraries::Netwrking::FTP{\t/* ... */}네임스페이스 앨리어스를 사용하면 네임스페이스의 이름을 다르게 표현하거나 기존 이름을 좀 더 짧게 만들 수 있다.namespace MyFTP = MyLibraries::Networking::FTP;참고 마크 그레고리, 『전문가를 위한 C++(4판)』, 남기혁" }, { "title": "[C++] 구조적 바인딩(Structured Binding)", "url": "/posts/Structured_Binding/", "categories": "C++", "tags": "C++", "date": "2023-05-15 00:00:00 +0900", "snippet": "구조적 바인딩(Structured Binding)C++17부터 도입되었으며, 구조적 바인딩을 이용하면 여러 개의 변수를 선언할 때 배열, 구조체, 페어 또는 튜플의 값으로 초기화할 수 있다.std::array&lt;int, 3&gt; values = { 11, 22, 33 };이 상태에서 x, y, z란 변수를 선언할 때 각각 앞에 나온 values ...", "content": "구조적 바인딩(Structured Binding)C++17부터 도입되었으며, 구조적 바인딩을 이용하면 여러 개의 변수를 선언할 때 배열, 구조체, 페어 또는 튜플의 값으로 초기화할 수 있다.std::array&lt;int, 3&gt; values = { 11, 22, 33 };이 상태에서 x, y, z란 변수를 선언할 때 각각 앞에 나온 values 배열에 담긴 값으로 초기화할 수 있다.구조적 바인딩을 적용하려면 반드시 auto 키워드를 붙여야 한다. 예를 들어 auto 자리에 int를 지정하면 안 된다.auto [x, y, z] = values;구조적 바인딩에서는 왼쪽에 나온 선언할 변수 개수와 오른쪽에 나온 표현식 값 개수가 반드시 일치해야 한다.구조적 바인딩은 배열뿐만 아니라 모든 멤버가 non-static이면서 public으로 선언된 데이터 구조라면 어떤 것(struct, pair, tuple 등)도 적용할 수 있다. 예를 들면 다음과 같다.struct Point { double mX, mY, mZ; };Point point;point.mX = 1.0; point.mY = 2.0; point.mZ = 3.0;auto [x, y, z] = point;참고 마크 그레고리, 『전문가를 위한 C++(4판)』, 남기혁" }, { "title": "[C++] Const & Reference", "url": "/posts/Const_Reference/", "categories": "C++", "tags": "C++", "date": "2023-05-06 00:00:00 +0900", "snippet": "Constconst 상수값을 상수로 선언할 수 있게 해주는 키워드이다.C 언어에서는 전처리 구문인 #define을 사용했지만 C++에서는 상수를 #define 대신 const로 정의하는 것이 바람직하다. #define은 전처리기가 처리하고, const는 컴파일러가 처리한다. const로 정의할 대상에 타입이나 스코프를 적용할 수 있다는 장점이 있다....", "content": "Constconst 상수값을 상수로 선언할 수 있게 해주는 키워드이다.C 언어에서는 전처리 구문인 #define을 사용했지만 C++에서는 상수를 #define 대신 const로 정의하는 것이 바람직하다. #define은 전처리기가 처리하고, const는 컴파일러가 처리한다. const로 정의할 대상에 타입이나 스코프를 적용할 수 있다는 장점이 있다.const int versionNumberMajor = 2;const int versionNumberMinor = 1;const std::string productName = \"Super Hyper Net Modulator\";const 매개변수C++에서는 non-const 변수를 const 변수로 캐스팅할 수 있다. 이렇게 하면 다른 코드에서 변수를 변경하지 않도록 어느정도 보호할 수 있다.const 매개변수로 구성된 함수안에서 매개변수의 값을 변경하면 컴파일 오류가 발생한다.void mysteryFunction(const std::string* someString){ *someString = \"Test\"; // 이 부분에서 컴파일 에러가 발생한다.}int main(){ std::string myString = \"The string\"; myteryFunction(&amp;myString); return 0;}ReferenceC++에서 제공하는 레퍼런스(참조)를 사용하면 기존 변수에 새 이름을 지정할 수 있다.int x = 42;int &amp; xReference = x;변수의 타입 뒤에 &amp;를 붙이면 그 변수는 레퍼런스가 된다. 코드에서 다루는 방법은 일반 변수와 같지만 내부적으로는 원본 변수에 대한 포인터로 취급한다. 앞에 나온 에에서 일반 변수 x와 레퍼런스 변수 xReference는 모두 같은 값을 가리킨다. 둘 중 한 변수에서 값을 변경하면 그 결과가 다른 변수에도 반영된다.레퍼런스 전달 방식일반적으로 함수에 전달한 변수는 값 전달 방식으로 처리한다. 예를 들어 함수의 매개변수에 정수를 전달하면 함수 안에는 그 정수의 복제본이 전달된다. 따라서 함수 안에서 원본 변수의 값을 변경할 수 없다. C에서는 스택 변수에 대한 포인터를 자주 사용했는데, 이런 방식을 사용하면 다른 스택 프레임에 있는 원본 변수를 수정할 수 있다. 이러한 포인터를 역참조하면 그 포인터가 현재 스택 프레임을 가리키지 않더라도 함수 안에서 그 변수가 가리키는 메모리의 값을 수정할 수 있지만, 포인터 연산이 많아져서 간단한 작업도 코드가 복잡해지는 단점이 있다.C++에서는 값 전달 방식보다 뛰어난 레퍼런스(참조) 전달 방식을 제공한다.void addOne(int i){ i++;\t// 복제본이 전달됐기 때문에 원본에는 아무런 영향을 미치지 않는다.}void addOne(int&amp; i){ i++;\t//원본 변수가 변경된다.}정수 타입에 대한 레퍼런스를 받는 함수를 호출하는 문장을 작성하는 방식은 정숫값을 받는 함수를 호출할 때와 똑같다.int myInt = 7;addOne(myInt);const 레퍼런스 전달 방식const 레퍼런스의 가장 큰 장점은 성능이다. 함수에 매개변수를 값으로 전달하면 그 값 전체가 복제된다. 하지만 레퍼런스로 전달하면 원본에 대한 포인터만 전달되기 때문에 원본 전체를 복제할 필요가 없다. 또한 const 레퍼런스로 전달하면 복제되지도 않고 원본 변수가 변경되지도 않는 장점을 모두 취할 수 있다.const 레퍼런스는 특히 객체를 다룰 때 유용하다. 객체는 대체로 커서 복제하는 동안 의도하지 않은 효과를 발생할 수 있기 때문이다.void printString(const std::string&amp; myString){ std::cout &lt;&lt; myString &lt;&lt; std::endl;}int main(){ std::string someString = \"Hello World\"; printString(someString); printString(\"Hello World\");\t//리터럴을 전달해도 된다. return 0;} 함수에 객체를 전달할 때 값으로 전달하기보다는 const 레퍼런스로 전달하는 것이 좋다. 그러면 불필요한 복제 작업을 피할 수 있다. 전달할 객체를 함수 안에서 수정하려면 non-const 레퍼런스로 전달한다.참고 마크 그레고리, 『전문가를 위한 C++(4판)』, 남기혁" }, { "title": "[C++] Thread", "url": "/posts/Thread/", "categories": "C++", "tags": "C++", "date": "2022-06-18 00:00:00 +0900", "snippet": "Thread프로세스와 쓰레드(Process &amp; Thread)프로세스(Process)프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위이다. 우리가 1개의 프로그램을 가리킬 때 보통 1개의 프로세스를 의미하며, 프로세스는 CPU의 코어에서 실행된다.CPU는 한 번에 한 개의 연산을 수행하는데 우리는 인터넷을 하면서 음악을 듣고, 게임을 하는...", "content": "Thread프로세스와 쓰레드(Process &amp; Thread)프로세스(Process)프로세스란, 운영체제에서 실행되는 프로그램의 최소 단위이다. 우리가 1개의 프로그램을 가리킬 때 보통 1개의 프로세스를 의미하며, 프로세스는 CPU의 코어에서 실행된다.CPU는 한 번에 한 개의 연산을 수행하는데 우리는 인터넷을 하면서 음악을 듣고, 게임을 하는 등 여러가지 일들을 동시에 할 수 있다. 이는 컨텍스트 스위칭(Context Switching) 이라는 기술 덕분이다.컨텍스트 스위칭(Context Switching)컴퓨터에서 프로그램이 실행될 때 겉으로 보기에는 프로그램이 연속적으로 쭈욱 작동하는 것 처럼 보이지만 실제로는 프로그램 하나가 잠시 실행되었다가, 다른 프로그램으로 스위칭한다.정확히는, CPU는 운영체제에게 처리하라고 시키는 명령어들을 실행할 뿐, 어떤 프로그램을 실행시키고, 얼마동안 실행시키고, 다음에 무슨 프로그램으로 스위칭 할지는 운영체제의 스케줄러가 결정한다.쓰레드(Thread)CPU 코어에서 돌아가는 프로그램 단위를 쓰레드(Thread)라고 한다. CPU의 코어 하나에서는 한 번에 한 개의 쓰레드의 명령을 실행시키게 된다.한 개의 프로세스는 최소 한 개의 쓰레드로 이루어져 있으며, 여러 개의 쓰레드로 구성될 수 있다. 이렇게 여러 개의 쓰레드로 구성된 프로그램을 멀티 쓰레드(Multi Thread) 프로그램이라고 한다.쓰레드와 프로세스의 가장 큰 차이점은 프로세스들은 서로 메모리를 공유하지 않는 반면에, 쓰레드는 서로 같은 메모리를 공유하는 점이다. 현대의 CPU는 여러 개의 코어를 지원 즉, 멀티 코어 CPU에서 여러 개의 코어에 각기 다른 쓰레드들이 들어가 동시에 여러 개의 쓰레드들을 효율적으로 실행할 수 있다.멀티 쓰레드(Multi Thread)그럼 어떤 상황일 때 프로그램을 멀티 쓰레드로 만드는 것이 유리할까?병렬 가능한 (Parallelizable) 작업들예를 들어 1부터 10000까지 더하는 작업을 구현한다고 가정해본다. 만약에 단일 쓰레드 프로그램으로 구현한다면 for문으로 1부터 10000까지 더하는 코드를 작성하면 된다.반면에 이를 쓰레드 10개로 만든다면, 쓰레드1이 1부터 1000까지 더하고, 쓰레드2가 1001부터 2000까지 … 쓰레드 10에서 9001 부터 10000까지 더한 뒤에 모든 쓰레드 작업 완료 후에 각각의 결과를 합치는 식으로 구현할 수 있다.// 단일 쓰레드로 구현한 1 ~ 10000 더하기for (int i = 1; i &lt;= 10000; ++i){ sum += i;}// 멀티 쓰레드로 구현한 1 ~ 10000 더하기 (쓰레드 10개)// Thread #1for (int i = 1; i &lt;= 1000; ++i){ sum[0] += i;}// Thread #2for (int i = 1001; i &lt;= 2000; ++i){ sum[1] += i;}... // 모든 쓰레드 실행 후for (int i = 0; i &lt;= 10; ++i){ sum += sum[i];}CPU 코어에서 덧셈 한 번에 1초가 걸린다고 했을 때, 단일 쓰레드의 경우 10000초가 걸리는 반면에, 멀티 쓰레드를 사용하였을 경우 CPU에 코어가 10개가 있어서 각 쓰레드들이 동시에 실행된다면, 각 쓰레드의 덧셈은 1000초가 걸리고, 마지막으로 합치는 10초를 포함하여 총 1010초가 걸리게 된다.이는 10배의 차이를 보인다.이렇게 어떠한 작업을 여러 개의 다른 쓰레드를 이용해서 좀 더 빠르게 수행하는 것을 병렬화(Parallelize)라고 한다.병렬화가 불가능한 작업병렬화가 불가능한 작업들도 있는데, 대표적인 예로 피보나치 수열 계산이 있다.피보나치 수열 계산은 연산A를 수행하기 위해 다른 연산B의 결과가 필요하기 때문이다.이와 같은 상황을 A가 B에 의존(Dependent)이라고 한다. 프로그램 논리 구조 상에서 연산들간의 의존 관계가 많을 수록 병렬화가 어려워지고, 다른 연산의 결과와 관계없이 독립적으로 수행할 수 있는 구조가 많을 수록 병렬화가 쉬워진다.대기 시간이 긴 작업들인터넷에서 웹사이트들을 긁어 모으는 프로그램을 구현해본다고 가정한다.int main(){ // 다운 받으려는 웹사이트와 내용을 저장하는 맵 map&lt;string, string&gt; url_and_content; for (auto itr = url_and_content.begin(); itr != url_and_content.end(); ++itr) { const string&amp; url = itr-&gt;first; // download 함수는 인자로 전달받은 url에 있는 사이트를 다운 받아 리턴한다. itr-&gt;second = download(url); }}ping은 내가 보낸 요청이 상대 서버에 도착해서 다시 나에게 돌아오는데 걸리는 시간을 의미한다. 보통 우리나라 안에서 웹사이트에 요청을 보낼 시에 ping이 30밀리초 정도이고, 해외의 경우 150에서 300까지 걸리게 되는데, 이 시간만큼 CPU를 기다리게 하는 것은 CPU 코어를 비효율적으로 사용하게 된다.위 그림은 컨텍스트 스위칭을 통해서 기다리는 시간 없이 CPU를 최대한으로 사용하는 것을 보여준다.참고 모두의 코드, https://modoocode.com/269" }, { "title": "[Unreal Engine] Assert", "url": "/posts/Assert/", "categories": "Unreal Engine", "tags": "Unreal Engine, C++", "date": "2022-05-29 00:00:00 +0900", "snippet": "Assert주어진 코드 조각이 가정하는 상황을 검증하는 도구이다.포인터의 NULL 여부를 검증하는 간단한 것 부터, 특정 함수에 재진입했는지와 같은 복잡한 검증도 가능하다.런타임 어서트 매크로는 3가지 카테고리가 있다. 실행 중지 (DO_CHECK=1 define에 따라 컴파일) 디버그 빌드에서 실행 중지 (DO_GUARD_SLOW define에 ...", "content": "Assert주어진 코드 조각이 가정하는 상황을 검증하는 도구이다.포인터의 NULL 여부를 검증하는 간단한 것 부터, 특정 함수에 재진입했는지와 같은 복잡한 검증도 가능하다.런타임 어서트 매크로는 3가지 카테고리가 있다. 실행 중지 (DO_CHECK=1 define에 따라 컴파일) 디버그 빌드에서 실행 중지 (DO_GUARD_SLOW define에 따라 컴파일) 실행 중지하지 않고 오류 보고 (DO_CHECK=0)언리얼 엔진에서는 이러한 유형의 검증을 하기 위한 매크로 시리즈가 제공되어 소개하려고 한다. 어서트 매크로의 첫 클래스는 어서트가 true가 아니라면 모든 실행을 중지한다. 디버거 안에서 실행중이라면, 어떻게 해서 그 지점에 이르렀는지 조사할 수 있도록 어서트가 중단점을 발동시킨다.check(표현식);이 매크로는 표현식을 실행한 뒤, 결과가 false면 실행을 중지시킨다. (DO_CHECK=1)check(Mesh != nullptr);check(bWasInitialized &amp;&amp; \"Did you forget to call Init()?\");verify(표현식);DO_CHECK가 켜져 켜져있으면, 이 매크로는 check()와 똑같은 역할을 하고, DO_CHECK가 꺼져 있어도 실행된다.변수 할당이 가정한 대로 되었는지 검증하는데 사용한다.verify((Mesh = GetRenderMesh()) != nullptr);checkf(표현식, …);표현식이 true가 아니면 디버깅에 도움이 되는 추가 정보를 출력하는 것이 가능하다. 컴파일 면에 있어서는 check()와 똑같다.checkf(WasDestroyed, TEXT(\"Failed to destroy Actor %s (%s)\"), *Actor-&gt;GetClass()-&gt;GetName(), *Actor-&gt;GetActorLabel());checkf(TCString&lt;ANSICHAR&gt;::Strlen(key) &gt;= KEYLENGTH(AES_KEYBITS), TEXT(\"AES_KEY needs to be at elast %d characters\"), KEYLENGTH(AES_KEYBITS));verifyf(표현식, …);checkf() 처럼 실행을 중지시키면서, 추가적인 디버그 메시지를 남긴다.verifyf(Module_libeay32, TEXT(\"Failed to load DLL %s\"), *DLLToLoad);checkCode(표현식);한번 실행되는 do/while 루프 안에서 표현식을 실행한다. DO_CHECK가 꺼져있으면 컴파일에서 제외된다. DO_CHECK가 꺼지면 코드가 제거되기 때문에 필수적인 부가 효과가 있는 표현식은 사용하면 안된다.checkCode(if(Object-&gt;HasAnyFlags(RE_PendingKill)) {UE_LOG(LogUObjectGlobals, Fatal, TEXT(\"Object %s is part of root set through has been marked RF_PendingKill!\"), *Object-&gt;GetFullName());});checkNoEntry();표현식을 받지 않으며, 절대 실행될 일이 없는 코드 경로를 표시하는 데 사용된다.switch(MyEnum){ case MyEnumvalue: break; default: checkNoEntry(); break;}checkNoReentry();호출이 주어진 함수에 재진입하는 것을 방지하기 위해 사용된다. 한 번 호출이 완료되기 전까지 다시 호출해서는 안될 함수에 사용한다.void NoReentry(){ checkNoReentry();}checkNoRecursion();checkNoReentry()와 같은 검사를 하나, 이름으로 그 의도를 더욱 명확히 알 수 있다.unimplemented();함수에 구현이 없어서 특정 클래스에서 호출하면 안되거나 덮어써야 하는 함수를 표시하는 데 사용된다.class FNoImpl{ virtual void DoStuff() { // You must override this unimplemented();}}checkSlow(), checkfSlow(), viryfiSlow()DO_GUARD_SLOW가 켜졌을 때만 실행된다. DO_GUARD_SLOW는 보통 디버그 빌드에만 키지만, 프로젝트에서 직접 변경이 가능하다.느리면서 규칙을 따지는 검사이며, Development 또는 Shipping 빌드에서는 필요하지 않다.이 매크로들의 기능은 느리지 않은 버전과 똑같다.checkSlow(List-&gt;HasCycle());checkfSlow(Class-&gt;IsA(AActor::StaticClass()), TEXT(\"Class (%s) is wrong type\"), Class-&gt;GetName());verifySlow(LastValue == Current); 런타임 어서트의 마지막 클래스는 실행은 중지시키지는 않지만, 문제 추적에 도움이 되는 콜스택을 만드는 데 사용된다. 이 매크로의 표현식은 항상 실행되며, 조건식 안에 넣을 수 있다. 이 매크로는 DO_CHECK 디파인으로 킨다.ensure(표현식);표현식을 검증하여 실패하면 그 지점까지 이르는 콜스택을 생성한다.if (ensure(InObject != NULL)){ InObject-&gt;Modify();}ensureMsg(표현식, 메시지);표현식을 검증, 리포트에 메시지를 추가시킨 콜스택을 생성한다.ensureMsg(Node != nullptr, TEXT(\"Node is invalid\"));ensureMsgf(표현식, 메시지, …);표현식을 검증, 생성된 리포트에 대한 콜스택과 짝지은 상세 정보를 포함시킨다.if (ensureMsgf(!bModal, TEXT(\"Could not create dialog because modal is set to (%d)\"), int32(bModal))){ // ...}모든 AssertionMacro들은 /UE4/Engine/Source/Runtime/Core/Public/Misc/AssertionMacros.h 에서 열람할 수 있다.참고 Unreal Engine docs : https://docs.unrealengine.com/5.0/ko/asserts-in-unreal-engine/" }, { "title": "[자료구조] 빅오 표기법 (big-O notation)", "url": "/posts/bigO/", "categories": "Data Structure", "tags": "Data Structure", "date": "2022-05-26 00:00:00 +0900", "snippet": "big-O알고리즘의 효율성을 나타내는 지표 혹은 언어이다.시간 복잡도알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한 것이다.점근적 실행 시 간 (asymptotic runtime), 또 는 big-O 시간에 대한 개념데이터 전송 알고리즘을 예로 들어 설명하면, 온라인 전송 : O(s), s는 파일의 크기이다. 파일의 크기가 증가함에...", "content": "big-O알고리즘의 효율성을 나타내는 지표 혹은 언어이다.시간 복잡도알고리즘을 수행하기 위해 프로세스가 수행해야하는 연산을 수치화 한 것이다.점근적 실행 시 간 (asymptotic runtime), 또 는 big-O 시간에 대한 개념데이터 전송 알고리즘을 예로 들어 설명하면, 온라인 전송 : O(s), s는 파일의 크기이다. 파일의 크기가 증가함에 따라 전송 시간 또한 선형 시간 또한 선형적으로 증가한다. 비행기를 통한 전송 : 파일 크기에 관계없이 O(1), 파일의 크기가 증가한다고 해서 전송하는 데 걸리는 시간이 늘어나지 않는다. 즉, 상수 시간만큼 소요된다. 상수가 얼마나 큰지, 선형식이 얼마나 천천히 증가하는지 관계없이 숫자가 커지다 보면 선형식은 언젠가 상수를 뛰어넘게 된다.big-O, big-Ω, big-θ big-O : 시간의 상한 big-Ω : 등가 개념 혹은 하한 big-θ : O와 Ω의 둘의 퍙균최선, 최악, 평균적인 경우최선의 경우는 잘 사용되지 않는다. 이유는 아무 알고리즘이나 취한 뒤 특수한 입력을 넣으면 O(1)로 동작하도록 만들 수 있기 때문이다.대부분의 알고리즘은 최악의 경우와 평균적인 경우가 같다. 가끔 이들이 달라서 최악과 평균 모두 언급해야 되기도 한다.공간 복잡도알고리즘에는 시간뿐 아니라 메모리(혹은 공간) 또한 신경 써야 한다.공간 복잡도는 시간 복잡도와 평행선을 달리는 개념이다.예를 들어, 크기가 n인 배열을 만들고자 한다면, O(n)의 공간이 필요하다. n × n 크기의 2차원 배열을 만들고자 한다면, O(n^2)의 공간이 필요하다.재귀 호출에서 사용하는 스택 공간 또한 공간 복잡도 계산에 포함된다. 예를 들어, 다음과 같은 코드는 O(n) 시간과 O(n) 공간을 사용한다.int sum(int n){ if (n &lt;= 0) { return 0;} return n + sum(n-1);}호출될 때마다 스택의 깊이는 깊어진다.sum(4)\t-&gt; sum(3)\t\t-&gt; sum(2)\t\t\t-&gt; sum(1)\t\t\t\t-&gt; sum(0)n번 호출했다고 해서 O(n) 공간을 사용한다고 말할 수 없는 경우도 있다.예를 들어, 0과 n 사이에서 인접한 두 원소의 합을 구하는 함수는int pairSumSequence(int n){ int sum = 0; for (int i = 0; i &lt; n; ++i) { sum += pairSum(i, i + 1);} return sum;}int pairSum(int a, int b){ return a + b;}위의 코드는 pairSum 함수를 O(n)번 호출했지만, 이 함수들이 호출 스택에 동시에 존재하지는 않으므로 O(1) 공간만 사용한다.상수항은 무시하라big-O는 단순히 증가하는 비율을 나타내는 개념이므로, 특수한 입력에 한해 O(N) 코드가 O(1) 코드보다 빠르게 동작하는 것은 가능성이 있다.이러한 이유로 수행시간에서 상수항을 무시한다. 즉, O(2N)으로 표기되어야 할 알고리즘을 실제로는 O(N)으로 표기한다.지배적이지 않은 항은 무시하라수식에서 지배적이지 않은 항은 무시해도 된다. O(N^2 + N)은 O(N^2)이 된다. O(N+logN)은 O(N)이 된다. O(5*2^n + 1000N^100)은 O(2^N)이 된다.수식에 합이 남아 있는 경우도 있다. O(B^2 +A)는 하나의 항으로 줄일 수 없다. (A와 B 사이에 존재하는 관계를 알고 있지 않는 이상).big-O 시간의 증가율을 나타내는 그래프 출처 : https://github.com/stunstunstun/python-algorithms여러 부분으로 이루어진 알고리즘 : 덧셈 vs 곱셈 덧셈 수행 시간 : O(A + B)for (int a : arrA){ print(a);}for (int b : arrB){ print(b);}알고리즘이 “A 일을 모두 끝마친 후에 B 일을 수행하라”의 형태라면 A와 B의 수행 시간을 더해야 한다. 곱셈 수행 시간 : O(A × B)for (int a : arrA){ for (int b : arrB) { print(a + \",\" + b);}}알고리즘이 “A 일을 할 때마다 B 일을 수행하라”의 형태라면 A와 B의 수행 시간을 곱해야 한다.상환 시간최악의 경우는 가끔 발생하지만 한 번 발생하면 그 후로 꽤 오랫동안 나타나지 않으므로 비용(수행 시간)을 분할 상환 한다는 개념이다.예를 들어, 동적 배열의 용량이 꽉 찼다면, 배열이 기존보다 크기가 두 배 더 큰 배열을 만든 뒤, 이전 배열의 모든 원소를 복사한다. (더블링)이때 삽입 연산의 수행 시간은? (N은 배열의 크기) 배열에 N개의 원소가 들어 있을 때 새로운 원소를 삽입하려면 O(N)이 걸린다. 크기가 2N개인 배열을 새로 만들고 기존의 모든 원소를 새 배열로 복사해야 하기 때문이다. 하지만 대다수의 경우에는 배열에 가용 공간이 존재하고 이때의 삽입 연산은 O(1)이 걸린다.배열의 크기가 2의 승수가 되었을 때 원소를 삽입하면 용량이 두 배로 증가한다. 1 + 2 + 4 + 8 + 16 +…+ N반대로 N에서 시작해서 1이 될 때까지 절반씩 줄어드는 수열은 X + X/2 + X/4 + X/8 + … + 1이다. 이를 합하면 대략 2N가 된다.따라서 N개의 원소를 삽입했을 때 필요한 시간은 O(2N)이고, 이를 분할 상환해보면 삽입 한 번에 필요한 시간은 O(1)이다. 예를 하나 더 들자면, 분할상환 분석은 부족한 금액 혹은 남는 금액을 전체 연산에서 서로 보충해가면서 평균 비용을 도출하는 구조를 기반으로 전체 연산의 평균 비용을 도출한다고 한다. 출처 : Eth Dev Post, https://hcn1519.github.io/articles/2017-05/amortized_analysislog N 수행 시간이진 탐색(binary search)를 예를 들어 설명하자면, 이진 탐색은 N개의 정렬된 원소가 들어 있는 배열에서 원소 x를 찾을 때 사용된다.먼저 원소 x와 배열의 중간값을 비교하고 ‘x==중간값’을 만족하면 이를 반환한다. ‘x &lt; 중간값’일 때는 배열의 왼쪽 부분을 재탐색하고 ‘x &gt; 중간값’일 경우에는 배열의 오른쪽 부분을 재탐색한다.{1, 3, 5, 7, 9, 11, 15}에서 1 검색\t1과 7 비교. 1이 7보다 작다.\t7보다 작거나 같은 {1, 3, 5}에서 검색\t\t1과 3 비교. 1이 3보다 작다.\t\t3보다 작거나 같은 {1}에서 검색\t\t\t1과 1 비교. 1을 찾았다!\t\t\t결과를 반환한다.처음에는 원소 N개가 들어있는 배열에서 시작한다. 한 단계가 지나면 탐색해야 할 원소의 개수가 N / 2로 줄어들고, 한 단계가 더 지나면 N / 4 개로 줄어든다. 그러다가 원소를 찾았거나 탐색해야 할 원소가 하나만 남으면 탐색을 중단한다.총 수행 시간은 N을 절반씩 나누는 과정에서 몇 단계 만에 1이 되는지에 따라 결정된다.즉, 2^k = N을 만족하는 K를 구할 때 로그(log)를 사용한다. 2^4 = 16 -&gt;log2_16 = 4 log2_N = k -&gt; 2^k = N 문제의 원소의 개수가 절반씩 줄어든다면 그 문제의 수행 시간은 O(logN)이 될 가능성이 크다.재귀적으로 수행 시간 구하기int f(int n){ if (n &lt;= 1) { return 1;} return f(n - 1) + f(n - 1);}함수 f가 두 번 호출된 것을 보고 O(N^2)라고 생각할 수 있지만, 코드를 하나씩 읽어가면서 수행 시간을 계산해 보자.f(4)는 f(3)을 두 번 호출한다. 또, f(3)은 f(2)를 두 번 호출하고.. f(1)까지 호출한다면?트리의 깊이가 N이고, 각 노드(즉, 함수 호출)는 두 개의 자식 노드를 갖고 있다. 따라서 깊이가 한단계 깊어질 때마다 이전보다 두 배 더 많이 호출하게 된다.같은 높이에 있는 노드의 개수를 세어 보면 아래와 같다. 깊이 노드의 개수 다른 표현방식 또 다른 표현방식 0 1   2^0 1 2 2 * 이전 깊이 = 2 2^1 2 4 2 * 이전 깊이 = 2 * 2^1 = 2^2 2^2 3 8 2 * 이전 깊이 = 2 * 2^2 = 2^3 2^3 4 16 2 * 이전 깊이 = 2 * 2^3 = 2^4 2^4 따라서 전체 노드의 개수는 2^0 + 2^1 + 2^2 + … + 2^N ( = 2^N - 1)이 된다.다수의 호출로 이루어진 재귀 함수에서 수행 시간은 보통 O(분기^깊이)로 표현되곤 한다.분기(branch)란 잭귀 함수가 자신을 재호출하는 횟수를 뜻한다.따라서 위의 경우에 수행 시간은 O(2^N)이 된다.이 알고리즘의 공간 복잡도는 O(N)이 된다. 전체 노드의 개수는 O(2^N)이지만, 특정 시각에 사용하는 공간의 크기는 O(N)이다. 따라서 필요한 가용 메모리의 크기는 O(N)이면 충분하다.참고 게일 라크만 맥도웰, 『코딩 인터뷰 완전 분석 189가지 프로그래밍 문제와 해법』, 이창현, 인사이트(2017), p60 ~ 70" }, { "title": "[자료구조] 정적배열과 동적배열", "url": "/posts/Array/", "categories": "Data Structure", "tags": "Data Structure", "date": "2022-05-15 00:00:00 +0900", "snippet": "배열직접적으로 값을 순차적으로 매핑한다.배열의 크기를 지정하고 선언하는 정적 배열(Static Array)와배열의 크기를 유동적으로 조절할 수 있는 동적 배열(Dynamic Array)가 있다.배열도 함수 포인터와 마찬가지로, 특정 배열을 선언하게 되면 배열의 이름으로 선언해주는 변수는 포인터이다.정적 배열 (Static Array)프로그램 실행 전에...", "content": "배열직접적으로 값을 순차적으로 매핑한다.배열의 크기를 지정하고 선언하는 정적 배열(Static Array)와배열의 크기를 유동적으로 조절할 수 있는 동적 배열(Dynamic Array)가 있다.배열도 함수 포인터와 마찬가지로, 특정 배열을 선언하게 되면 배열의 이름으로 선언해주는 변수는 포인터이다.정적 배열 (Static Array)프로그램 실행 전에 미리 공간을 할당받기 때문에, 배열의 크기가 프로그램이 실행되기 전에 미리 컴파일 타임에 정해져야 한다. 배열의 크기가 리터럴 상수가 아닌 변수로 넣고 싶다면 const가 붙은 변수, 즉 상수를 넣어야 한다. const int length = 3;int array[length]; 정적 배열은 주소를 바꾸는 것이 불가능하다. array의 배열 이름은 array의 주소를 담고 있는 상태, 다른 배열의 주소를 담게끔 값을 바꿀 수 없다. 동적 배열 (Dynamic Array)단일 변수에 대한 동적 할당뿐만 아니라 배열 변수를 동적 할당할 수 있다.컴파일 타임에 배열 길이를 정하는 정적 배열(Static Array)과 다르게 배열을 동적으로 할당하면 런타임 동안에 배열 길이를 정할 수 있다.동적으로 배열을 할당하려면, new[] 연산자와 delete[] 연산자를 사용해야 한다.동적으로 배열 할당하기 (Dynamically allocating arrays)#include &lt;iostream&gt;using namespace std;int main(){ int length; cin &gt;&gt; length;\t// 실행 중에 입력으로 결정된 크기 int* array = new int[length];\t// 동적할당 for (int i = 0; i &lt; length; ++i)\t//원소 대입 { cout &lt;&lt; *(array + i) &lt;&lt; \"\\t\";\t// array[i]와 같음\t} delete [] array;\t//메모리 해제}배열을 할당할 때는 new[]와 같은 배열 버전의 new 연산자를 사용해야 한다.동적 배열의 메모리는 정적 배열에 사용되는 메모리와 다른 위치에서 할당하므로 배열의 크기가 상당히 클 수 있다.C++에서 많은 메모리를 할당해야 하는 프로그램은 동적으로 메모리를 할당하는게 일반적이다.동적으로 배열 해제하기 (Dynamically deleting arrays)동적으로 할당된 배열을 해제할때는 delete[] 연산자를 사용한다.이것은 단일 변수 대신 여러 변수를 정리해야 한다는 것을 CPU에 알려준다.동적 할당에서 프로그래머가 자주하는 실수 중 하나는 동적으로 할당된 배열을 해제할 때 delete[] 대신 delete를 사용하는 것이다.배열에서 delete의 스칼라 버전을 사용하면 데이터 손상, 메모리 누수, 충돌 또는 기타 문제와 같은 정의되지 않은 동작이 발생한다.배열 해재시 new[]가 변수에 할당된 메모리양을 추적하여 delete[]는 적절한 메모리를 해제할 수 있다. 프로그래머는 이 크기, 길이에 접근할 수 없다.동적 배열 초기화(Initializing dynamically allocated arrays) 동적 배열을 0으로 초기화 int* array = new int[length](); C++ 11부터 초기화 리스트(Intializer list)를 사용해 동적 배열을 초기화할 수 있다. int staticArray[5] = {9,8,5,2,2};\t// C++03 정적 배열 초기화int* array = new int[5] {9,8,5,2,2};\t// C++11 동적 배열 초기화 C++ 11에서는 유니온 초기화를 사용하여 고정 배열도 초기화 할 수 있다. int staticArray[5] {9,8,5,2,2};\t// C++11 정적 배열 초기화char staticArray[14] {\"Hello, world!\"}; // C++11 정적 배열 초기화 동적 배열을 C 스타일 문자열로 초기화 할 수 없다. char* array = new char[14] {\"Hello, world!\"};\t// C++ 11에서 동작하지 않음 동적 배열은 명시적으로 길이를 설정해 선언해야 한다. int staticArray[] {1,2,3};\t// Okay : 정적 배열의 암시적 크기 int* dynamicArray1 = new int[] {1,2,3};\t// Not Okay : 동적 배열의 암시적 크기 int* dynamicArray2 = new int[3] {1,2,3};\t// Okay : 동적 배열의 명시적 크기 참고 소년코딩 https://boycoding.tistory.com/205 평생 공부 블로그, https://ansohxxn.github.io/cpp/chapter6-11/ 완숙의 블로그, https://egg-money.tistory.com/161" }, { "title": "[백준 11654] 아스키 코드", "url": "/posts/11654/", "categories": "Algorithm", "tags": "Algorithm, Boj", "date": "2022-04-11 00:00:00 +0900", "snippet": "문제 문제 링크풀이VS Code C++ 빌드 환경 구축 후 풀어보았다.#include &lt;iostream&gt;using namespace std;int main(){ char input; cin &gt;&gt; input; cout &lt;&lt; (int)input; return 0;}제출 이후 다른 분들의 제출 답안을 ...", "content": "문제 문제 링크풀이VS Code C++ 빌드 환경 구축 후 풀어보았다.#include &lt;iostream&gt;using namespace std;int main(){ char input; cin &gt;&gt; input; cout &lt;&lt; (int)input; return 0;}제출 이후 다른 분들의 제출 답안을 살펴보았는데, 형변환시 (int)가 아닌 static_cast(int)를 사용한 코드가 보였다.static_cast가 궁금하여 구글링 해 본 결과 잘 정리된 블로그가 있어 static_cast뿐만 아니라 dynamic_cast와 C언어 타입 형변환을 이해할 수 있었다.기존에 사용하는 C언어 타입의 형변환은 형변환 당시의 타입에 대해 상관하지 않고 형변환을 한다. 이렇게 되었을 때 발생되는 문제점은 기초 클래스의 포인터 형을 유도 클래스의 포인터 형으로 변환할 수 있다는 점이다.그래서 이 대신 static_cast를 사용하여 C언어 타입의 형변환보다 엄격하게 형변환을 할 수 있게 한다.dynamic_cast는 업캐스팅은 허용하지만 다운캐스팅은 허용하지 않는 형변환인데 다운캐스팅과 업캐스팅 관련하여 블로그에 잘 정리되어 있으니 참고하면 좋을 것 같다.정리하자면 static_cast 와 dynamic_cast의 차이점은 static_cast는 컴파일시에 형변환하는 연산자이고, dynamic_cast는 런타임에 형변환하는 연산자이다.또한 static_cast와 dynamic_cast 모두 괴상한(?) 형변환은 허용하지 않지만, static_cast는 다운캐스팅/업캐스팅 모두 허용하여 사용자에게 책임이 있는 반면, dynamic_cast는 업캐스팅은 허용하지만 다운캐스팅을 허용하지 않는다.정리난이도가 쉬운 문제에도 배울점이 있었다는 점이 뿌듯하였고,다음에는 새로 알게된 개념을 자세히 정리하는 글을 따로 쓰는게 좋을 것 같다는 생각이 들었다.계속 글을 정리하는 습관을 들여서 알고 있는 지식에 관하여 남들이 이해할 수 있도록 설명을 잘하는 내가 되었으면 좋겠다 !" }, { "title": "[백준 2557] Hello World", "url": "/posts/2557/", "categories": "Algorithm", "tags": "Algorithm, Boj", "date": "2022-04-10 00:00:00 +0900", "snippet": "문제 문제 링크풀이블로그 포스팅 연습 겸 문제 풀이를 해보았다.cpp에서 출력 함수인 cout을 사용하였다.#include &lt;iostream&gt;int main(){ std::cout &lt;&lt; \"Hello World!\"; return 0;}", "content": "문제 문제 링크풀이블로그 포스팅 연습 겸 문제 풀이를 해보았다.cpp에서 출력 함수인 cout을 사용하였다.#include &lt;iostream&gt;int main(){ std::cout &lt;&lt; \"Hello World!\"; return 0;}" }, { "title": "Welcome", "url": "/posts/welcome/", "categories": "", "tags": "", "date": "2022-03-29 00:00:00 +0900", "snippet": "첫 포스팅Hello !배울 때 마다 정리오늘부터 시작 !파이팅 !", "content": "첫 포스팅Hello !배울 때 마다 정리오늘부터 시작 !파이팅 !" } ]
