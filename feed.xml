<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://rightday.github.io/</id><title>RightDay</title><subtitle>A minimal, responsive, and powerful Jekyll theme for presenting professional writing.</subtitle> <updated>2024-03-31T00:55:49+09:00</updated> <author> <name>RightDay</name> <uri>https://rightday.github.io/</uri> </author><link rel="self" type="application/atom+xml" href="https://rightday.github.io/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://rightday.github.io/"/> <generator uri="https://jekyllrb.com/" version="4.3.3">Jekyll</generator> <rights> © 2024 RightDay </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>[Git] Git Command</title><link href="https://rightday.github.io/posts/git_command/" rel="alternate" type="text/html" title="[Git] Git Command" /><published>2023-06-22T00:00:00+09:00</published> <updated>2023-08-30T00:00:00+09:00</updated> <id>https://rightday.github.io/posts/git_command/</id> <content src="https://rightday.github.io/posts/git_command/" /> <author> <name>RightDay</name> </author> <category term="Git" /> <summary> Git Command 설정 초기화 git config --global user.name "Your name" git config --global user.email "eamil@email.com" 커밋하지 않고 변경사항 저장 git stash git stash pop Git 저장소에 포함되지 않은 파일 삭제 git clean 수정한 파일 되돌리기 git checkout -- filename 모두 되돌리기 git restore . </summary> </entry> <entry><title>[Unreal Engine] Circular Ring Material</title><link href="https://rightday.github.io/posts/CircularRing/" rel="alternate" type="text/html" title="[Unreal Engine] Circular Ring Material" /><published>2023-06-21T00:00:00+09:00</published> <updated>2023-06-21T00:00:00+09:00</updated> <id>https://rightday.github.io/posts/CircularRing/</id> <content src="https://rightday.github.io/posts/CircularRing/" /> <author> <name>RightDay</name> </author> <category term="Unreal Engine" /> <summary> 원형의 Progress Bar 혹은 차트에 활용 </summary> </entry> <entry><title>[C++] 스트링 리터럴(String Literal)</title><link href="https://rightday.github.io/posts/String_Literal/" rel="alternate" type="text/html" title="[C++] 스트링 리터럴(String Literal)" /><published>2023-06-04T00:00:00+09:00</published> <updated>2023-06-04T00:00:00+09:00</updated> <id>https://rightday.github.io/posts/String_Literal/</id> <content src="https://rightday.github.io/posts/String_Literal/" /> <author> <name>RightDay</name> </author> <category term="C++" /> <summary> 스트링 리터럴(String Literal) cout &amp;lt;&amp;lt; "hello" &amp;lt;&amp;lt; endl; 여기 나온 ‘hello’처럼 변수에 담지 않고 곧바로 값으로 표현한 스트링을 스트링 리터럴(String Literal)이라고 한다. 스트링 리터럴은 내부적으로 메모리의 읽기 전용 영역에 저장된다. 그래서 컴파일러는 같은 스트링 리터럴이 코드에 여러번 나오면 그중 한 스트링에 대한 레퍼런스를 재사용하는 방식으로 메모리를 절약한다. 이를 리터럴 풀링(Literal Pooling)이라 한다. 스트링 리터럴을 변수에 대입할 수는 있지만, 메모리의 읽기 전용 영역에 있게 되거나 동일한 리터럴을 여러 곳에서 공유할 수 있기 때문에 변수에 저장하면 위험하다. C++ 표준에서는 스트링 리터럴을 ‘co... </summary> </entry> <entry><title>[C++] 네임스페이스(Namespace)</title><link href="https://rightday.github.io/posts/Namespace/" rel="alternate" type="text/html" title="[C++] 네임스페이스(Namespace)" /><published>2023-05-16T00:00:00+09:00</published> <updated>2023-06-02T00:00:00+09:00</updated> <id>https://rightday.github.io/posts/Namespace/</id> <content src="https://rightday.github.io/posts/Namespace/" /> <author> <name>RightDay</name> </author> <category term="C++" /> <summary> 네임스페이스(Namespace) 네임스페이스는 코드에서 이름이 서로 충돌하는 문제를 해결하기 위해 나온 개념이다. 예를 들어 foo() 함수를 정의해서 코드를 작성하다가 외부 라이브러리를 추가했더니 거기에도 foo() 함수가 있는 경우가 있다. 이때 컴파일러는 foo()란 이름만 보고서는 어느 함수를 가리키는지 알 수 없다. 이럴 때 네임스페이스를 사용하면 어떤 이름이 어디에 속해 있는지 문맥을 정의할 수 있다. namespace.h namespace mycode { void foo(); } 네임스페이스는 이렇게 함수나 메서드의 선언뿐만 아니라 구현 부분도 묶을 수 있다. 예를 들어 foo() 함수의 구현 부분을 namespace.cpp에 작성할 때 네임스페이스를 지정하는 방법은 다... </summary> </entry> <entry><title>[C++] 구조적 바인딩(Structured Binding)</title><link href="https://rightday.github.io/posts/Structured_Binding/" rel="alternate" type="text/html" title="[C++] 구조적 바인딩(Structured Binding)" /><published>2023-05-15T00:00:00+09:00</published> <updated>2023-05-15T00:00:00+09:00</updated> <id>https://rightday.github.io/posts/Structured_Binding/</id> <content src="https://rightday.github.io/posts/Structured_Binding/" /> <author> <name>RightDay</name> </author> <category term="C++" /> <summary> 구조적 바인딩(Structured Binding) C++17부터 도입되었으며, 구조적 바인딩을 이용하면 여러 개의 변수를 선언할 때 배열, 구조체, 페어 또는 튜플의 값으로 초기화할 수 있다. std::array&amp;lt;int, 3&amp;gt; values = { 11, 22, 33 }; 이 상태에서 x, y, z란 변수를 선언할 때 각각 앞에 나온 values 배열에 담긴 값으로 초기화할 수 있다. 구조적 바인딩을 적용하려면 반드시 auto 키워드를 붙여야 한다. 예를 들어 auto 자리에 int를 지정하면 안 된다. auto [x, y, z] = values; 구조적 바인딩에서는 왼쪽에 나온 선언할 변수 개수와 오른쪽에 나온 표현식 값 개수가 반드시 일치해야 한다. 구조적 바인딩은 배열뿐만... </summary> </entry> </feed>
