---
title: "[C++] 스트링 리터럴(String Literal)"
excerpt: "스트링 리터럴(String Literal)"

categories:
- C++
tags:
- [C++]

toc: true
toc_sticky: true

date: 2023-06-04
last_modified_at: 2023-06-04
---
# 스트링 리터럴(String Literal)

```cpp
cout << "hello" << endl;
```

여기 나온 'hello'처럼 변수에 담지 않고 곧바로 값으로 표현한 스트링을 **스트링 리터럴(String Literal)**이라고 한다.

스트링 리터럴은 내부적으로 **메모리의 읽기 전용 영역에 저장**된다. 그래서 컴파일러는 같은 스트링 리터럴이 코드에 여러번 나오면 그중 한 스트링에 대한 **레퍼런스를 재사용**하는 방식으로 메모리를 절약한다. 이를 **리터럴 풀링(Literal Pooling)**이라 한다.

스트링 리터럴을 변수에 대입할 수는 있지만, 메모리의 읽기 전용 영역에 있게 되거나 동일한 리터럴을 여러 곳에서 공유할 수 있기 때문에 **변수에 저장하면 위험**하다. C++ 표준에서는 스트링 리터럴을 'const char가 n개인 배열' 타입으로 정의하고 있다. const 없이 char* 타입 변수에 스트링 리터럴을 대입하더라도 그 값을 변경하지 않는 한 프로그램 실행에는 아무런 문제없다. 그러나 스트링 리터럴을 **수정**하는 동작에 대해서는 명확히 정의돼 있지 않다.

```cpp
char* ptr = "hello"; 	// 변수에 스트링 리터럴을 대입한다.
ptr[1] = 'a';			// 결과를 예측할 수 없다.
```

스트링 리터럴을 참조할 때는 const 문자에 대한 포인터를 사용하는 것이 훨씬 안전하다.

```cpp
const char* ptr = "hello";	// 변수에 스트링 리터럴을 대입한다.
ptr[1] = 'a';				// 읽기 전용 메모리에 값을 쓰기 때문에 에러가 발생한다.
```

문자 배열(char[])의 초깃값을 설정할 때도 스트링 리터럴을 사용한다. 이때 컴파일러는 **주어진 스트링을 충분히 담을 정도로 큰 배열을 생성한 뒤 여기에 실제 스트링값을 복사**한다. 컴파일러는 이렇게 만든 스트링 리터럴을 **읽기 전용 메모리에 넣지 않으며 재사용하지도 않는다.**

```cpp
char arr[] = "hello";	// 컴파일러는 적절한 크기의 문자 배열 arr을 생성한다.
arr[1] = 'a';			// 이제 스트링을 수정할 수 있다.
```



## 로 스트링 리터럴(Raw String Literal)

로 스트링 리터럴(Raw String Literal)이란 여러 줄에 걸쳐 작성한 스트링 리터럴로서, 그 안에 담긴 인용부호를 이스케이프 시퀀스로 표현할 필요가 없고, \t나 \n과 같은 이스케이프 시퀀스를 일반 텍스트로 취급한다.

#### 에러 예제

```cpp
const char* str = "Hello "World"!";	// 에러가 발생한다!
```

#### 이스케이프 시퀀스

```cpp
const char* str = "Hello \"World\"!";
```

#### 로 스트링 리터럴 예제

**R"(**로 시작해서 **)"**로 끝난다.

```cpp
const char* str = R"(Hello "World"!)";	
```

로 스트링 리터럴을 사용하지 않고 여러 줄에 걸친 스트링을 표현하려면 스트링 안에서 줄이 바뀌는 지점에 \n을 넣어야 한다.

```cpp
const char* str = "Line 1\nLine 2";
```

로 스트링 리터럴을 표현할 때는 \n 대신 엔터키를 누르면 된다.

```cpp
const char* str = R"(Line 1
Line2)";
```



### 확장 로 스트링 리터럴(Extended Raw String Literal)

로 스트링 리터럴은 )"로 끝나기 때문에 그 안에 )"를 넣을 수 없다. 넣게 되면 에러가 발생한다.

```cpp
const char* str = R"(Embedded )" characters)";	// 에러가 발생한다.
```

)"를 추가하려면 **확장 로 스트링 리터럴(Extended Raw String Literal)** 구문으로 표현해야 한다.

```cpp
R"d-char-sequence(r-char-sequence)d-char-sequence"
```

여기서 r-char-sequence에 해당하는 부분이 실제 로 스트링이다. d-char-sequence라고 표현한 부분은 **구분자 시퀀스(Delimeter Sequence)**로서, 반드시 **로 스트링 리터럴의 시작과 끝에 똑같이 나와야한다.** 이 구분자는 **최대 16개의 문자**를 가질 수 있다. 이때 구분자 시퀀스는 **로 스트링 리터럴 안에 나오지 않는 값으로 지정**해야 한다.

#### 구분자 시퀀스 수정한 예제

```cpp
const char* str = R"-(Embedded )" characters)-";
```



로 스트링 리터럴을 사용하면 데이터베이스 쿼리 스트링이나 정규표현식, 파일 경로 등을 쉽게 표현할 수 있다.







#### 참고

> 마크 그레고리, 『전문가를 위한 C++(4판)』, 남기혁
>

